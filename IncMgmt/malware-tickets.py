#!/usr/bin/python3

# This will take information from various malware, intrusion detection,
# and other blinky light systems, and create a corresponding
# incident ticket on the tracking appliance blinky lights so work can
# be performed by operational teams

import os
import json
from uniqify import uniqify
import requests

from redmine import Redmine

os.chdir(os.path.expanduser("~") + "/.incmgmt/")

## Standard prefs for these scripts. Move to prefs file TODO
prefs = open('ov_prefs-dev.txt','r')
redmine_project = prefs.readline().rstrip()
redmine_server = prefs.readline().rstrip()
redmine_key = prefs.readline().rstrip()
sn_server = prefs.readline().rstrip()
user = prefs.readline().rstrip()
pwd = prefs.readline().rstrip()
severity_filter = prefs.readline().rstrip()
ov_report = prefs.readline().rstrip()
preamble =  prefs.readline().rstrip()
prefs.close()


## Here are things that need to be placed in a preferences file TODO
#reportfile = '/media/sf_Downloads/FireEye-alerts-short.json'
reportfile = '/home/ktneely/Downloads/Alert_Details_sjccms01_20141218_155759083876445000.json'

sub_base = "Malicious code activity detected on "
sys_type = "src"  # global identifier of the interesting system type
redmine = Redmine(redmine_server, requests={'verify': False}, \
                key=redmine_key, version='2.5.1')
#project_name = "Incident_Management"
project = redmine.project.get(redmine_project)
tracker_id = 2 # TODO add to prefs file # 2 on dev, Y on prod 


# Generates an unique index of the specified systems.
# System type "sys_type" takes a JSON key
def genIndex():
    hosts = []
    i = 0
    while i < len(data["alert"]):
        hosts.append(data["alert"][i][sys_type]["ip"])
        i += 1
    index = uniqify(hosts)
    return index

# Extract all relevant information on a per-host basis
def ExtractFEAlerts(host):
    i = 0
#    print("Reviewing JSON data")
    while i < len(data["alert"]):    # page through the data
        #print(data["alert"][i][sys_type])
        if str(data["alert"][i][sys_type]["ip"]) == str(host):   # if match, collect the relevant alert data
            try:
                hostname = data["alert"][i]["src"]["host"]
            except KeyError:
                hostname = "reverse lookup failed"
            try:
                dst = data["alert"][i]["dst"]["ip"]
            except KeyError:
                dst = "none"
            try:
                severity = data["alert"][i]["severity"]
            except KeyError:
                break # no need to continue severity = "none"
            try: 
                malware = data["alert"][i]["explanation"]\
                  ["malware-detected"]["malware"]["name"]
            except TypeError:
                malware = "unknown"
            try:
                activity = data["alert"][i]["explanation"]\
                  ["malware-detected"]["malware"]["stype"]
            except TypeError:
                activity = "No Data"
            except KeyError:
                activity = "No Data"
            alert_url = data["alert"][i]["alert-url"]
            time = data["alert"][i]["occurred"]
            return dst, hostname, malware, severity, activity, \
              time, alert_url
        i += 1

## determine criticality factors
# impact and urgency are used for Service Now
# priority is used for Redmine
def criticality(severity):
    if severity == "crit":
        impact = 2
        urgency = 1
        priority = 5
    elif severity == "majr":
        impact = 2
        urgency = 2
        priority = 4
    else:
        impact = 3
        urgency = 3
        priority = 3
    return impact, urgency, priority

def sn_issue(host, redmine_url, impact, urgency, wikipage):
    ## Create the incident in ServiceNow
        # Create the headers
    headers = {"Content-Type":"application/json","Accept":"application/json"}
    # Construct the incident JSON object
    incident_data = '{'  + \
        '"short_description":' + '"Malware detected on: ' + host + '",' + \
        '"description":' + '"For full information, see: ' + \
          redmine_url + '  and for cleaning instructions, see: ' + \
          wikipage + '",'\
        '"u_category":' + '"Information Security",' + \
        '"u_subcategory":' + '"Malware",' + \
        '"impact":' + '"' + str(impact)  + '",' + \
        '"urgency":' + '"' + str(urgency)  + '",' + \
        '"contact_type":"Alert"' + '}' 
    # Create the incident on the Service Now system
    response = requests.post(sn_server, auth=(user, pwd), \
        headers=headers, data=incident_data)
    # Capture the ticket number and unique identifier
    if response.status_code != 201: 
        print('Status:', response.status_code, 'Headers:', \
            response.headers, 'Error Response:',response.json())
        exit()
    sn_ticket = response.json()['result']['number']
    sys_id = response.json()['result']['sys_id']
    print("service now ticket created")
    return sn_ticket, sys_id
        
def CheckTickets(host):
    # checks for an active ticket for identified host, based on the
    # short description
    short_desc = sub_base + host
    i = 0
    while i < len(project.issues):
        if str(project.issues[i]) == short_desc:
            incident_id = project.issues[i].id
            print("Found a matching ticket in Redmine")
            return incident_id
        i += 1
    return None

            
def CreateRedmineTicket(host, priority, body):
    subject = sub_base + host
    new_issue = redmine.issue.create(project_id = redmine_project, \
         subject = subject, tracker_id = tracker_id, \
         priority_id = priority, description = body)
    redmine_issue_id = str(new_issue.id)
    redmine_url = redmine_server + "/issues/" + redmine_issue_id
    print("Created ticket " + str(new_issue))
    return redmine_url, redmine_issue_id 

def UpdateRedmineTicket(ticket, notes):
    redmine.issue.update(ticket, notes = notes)
    print("Updated ticket" + str(ticket))
    return None


# Log to ticketlog & opentix

# Perform OSINT Lookups
def GatherIntel(target):
    # Use Automater http://www.tekdefense.com/automater/
    # GitHub download: https://github.com/1aN0rmus/TekDefense-Automater
    os.chdir(os.path.expanduser("~") + "/bin/Automater")  # set WD 
    command = "/home/ktneely/bin/Automater/Automater.py " + target
    output = os.popen(command)
    text = output.read()
    print(text)   #DEBUG  to see what's going on.
    os.chdir(os.path.expanduser("~") + "/.incmgmt/")   # reset the WD
    return text

# Perform lookups against Vectra
# https://monza.arubanetworks.com/api/hosts/?last_source=10.11.8.183&page=last


# main
json_data=open(reportfile)  # open the data file
data=json.load(json_data)   # parse the JSON in the file
index = genIndex()
for host in index:
    print("\n \n processing: " + host)
    dst, hostname, malware, severity, activity, time, alert_url = \
      ExtractFEAlerts(host)
    print(dst)
    check =  CheckTickets(host) # check for existing redmine ticket
    print("Redmine ticket info: " + str(check), severity)   #DEBUG
    impact, urgency, priority = criticality(severity)
    # create a link to a wiki page with more info on specific malware
    wikipage = redmine_server + "/projects/incident_management/wiki/" + \
      malware.translate({ord(i):None for i in '.'}) #remove dots 
#   Perform OS-INT lookups
    intel = GatherIntel(dst)
    content = "Information Security network monintoring devices \
      have identified a potential compromise on the network. \n \
      Please check the following system for the following: \n \
    * Affected Host: " + host + "\n" \
    "* Last identified hostname: " + hostname + " (please verify)\n" \
    "* Destination: " + dst + "\n" \
    "* Malware family: [[" + malware + "]] \n" \
    "* Activity Observed: " + activity + "\n" \
    "* Detection Occurred at: " + time + "\n" \
    "* FireEye alert URL: " + alert_url + "\n \n" \
    "Open Source Intel: \n" + intel + "\n"
    if check is not None:
        # update existing tickets with additional info
        UpdateRedmineTicket(check, content)
    elif (check is None and (severity == ( "crit" or "majr" ))):
        # Create a ticket on the redmine server and return its ID
        redmine_url, redmine_issue_id = CreateRedmineTicket(host, priority, content)
        sn_ticket, sys_id = sn_issue(host, redmine_url, impact, urgency, wikipage)
    elif severity == ("crit" or "majr"):
        UpdateRedmineTicket(check, content)
        # TODO perform a lookup in opentix and UpdateSNTicket(sn_ticket)
    else: print("Alert severity below threshold")

json_data.close()

